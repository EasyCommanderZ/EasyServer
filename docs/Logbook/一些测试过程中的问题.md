# 测试过程中发现的问题

测试大部分过程还是比较顺利的，主要是因为在记录这个文档之前的编码过程很多问题已经出现并解决了。但是在做测试（主要是性能测试）的过程中还是发现了一些问题，记录一下。

## 性能测试期间发现性能低下

在 WebBench 的测试过程中，发现成功的连接数和失败的连接数都是0，很郁闷。网上搜索了一下之后发现 WebBench 好像需要服务端主动将连接关闭之后才能算做一次有效的连接，遂试着修改关闭时间为一个非常短的值。

这次操作过后，发现数据是有了，但是和期望的测试效果还是差了非常多，感觉很奇怪。于是去看了看 WebBench 的源代码，发现只要是读完来自服务端发送的内容并且关闭连接之后，就算一次成功的请求，那么这样的话就说不通了，既然如此，那么服务端不主动关闭也是可以的。但是成功连接和失败连接都是0，到底是阻塞在哪了？

首先肯定排除 WebBench 的问题，但是可以从 WebBench 入手来排查问题。

首先运行一个全新的 WebBench 测试，然后观察日志。发现所有的连接时长都和测试时长接近，也就是说在测试的运行时间结束后连接才被关闭了：

第一条连接建立：

![firstConnStart](../docResource/firstConnStart.png)

第一条连接关闭：

![](../docResource/firstConnClose.png)

使用 http 访问，得到如下结果：

```bash
$ http 127.0.0.1:1316                 
HTTP/1.1 200 OK
Connection: keep-alive
Content-length: 9
Content-type: text/html
Server: EasyServer
keep-alive: max=6, timeout=120

TEST PAGE
```

而在我本地对云端访问时，则是：

```bash
HTTP/1.1 200 OK
Connection: close
Content-Length: 9
Content-Type: text/html
Server: EasyServer

TEST PAGE
```

并且在后面的访问中，出现了错误提示：

```
writen error: Broken pipe
```

猜测应该是出现了连接断开不正确的问题。找到 writen 的所有引用，检查逻辑。于是把测试过程中的长连接关闭，WebBench 出现结果，但是还是很低。并且这样的问题在于，这种修改是没有必要的，如果访问是不存在的页面，那么连接默认是主动关闭的，但是前面的测试里面并没有。所以可以确定处理逻辑中是有问题的。

接下来进行错误排查。首先采取的方式比较粗暴，由于是仿照其他项目写的代码，我将另有一个项目的 HttpData 类移植到了 EasyServer 中。因为接口的类型几乎是一样的（都是按照 muduo 的设计思路实现的），HttpData 的设计和实现也相对对立，所以仅做了一些参数上的修改就可以进行移植。

接下来进行测试，发现 WebBench 的结果正常，并且比使用正则进行请求解析的项目要高出不少，那么就可以确定几个问题：

1. 问题就在 HttpData 中，EventLoop 等事件处理类的逻辑是没有问题的
2. 使用正则表达式进行请求解析对于性能有比较大的约束
3. HttpData 中的处理逻辑是肯定有问题的，并且主要在请求解析的部分，因为返回内容的逻辑仅有一个handleWrite，而它的调用也是在读的过程中调用的。换言之，处理逻辑的核心就是请求的解析

接下来就主要对请求解析的部分进行排查了。

